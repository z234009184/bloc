<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CodeMan的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://codeman.netlify.app/"/>
  <updated>2020-07-11T08:16:25.710Z</updated>
  <id>https://codeman.netlify.app/</id>
  
  <author>
    <name>CodeMan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter中Widget、Element、RenderObject三者的关系与作用</title>
    <link href="https://codeman.netlify.app/2020/06/20/flutter/flutter-widget/"/>
    <id>https://codeman.netlify.app/2020/06/20/flutter/flutter-widget/</id>
    <published>2020-06-20T06:26:40.000Z</published>
    <updated>2020-07-11T08:16:25.710Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h3><ul><li>在Flutter中, 一切皆Widget, Widget是不可变的, 每个Widget状态都代表一帧<br>通俗来说只要页面发生了变化,对应的Widget就一定改变了<br>所以Widget很轻量级</li></ul><h3 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h3><ul><li>Widget的加载,生命周期和更新流程;RenderObject的创建、更新等机制;child的加载更新行为, 都是Element实现的<br>所以Element就像是一个控制者一样起到主导作用</li><li>此外Element还保存着Widget的状态信息,从而实现了跨Widget的状态恢复</li><li>因此 <strong>Widget作为配置文件描述如何渲染页面, 多个Widget会组合成 Widget Tree ; 而Element表示 Widget Tree 中特定位置的实例, 多个Element在 mounted(挂载到页面)之后, 会构成一课 Element Tree ; Element只有在 mounted 之后才算激活, 激活之后如果Element存在RenderObject, Element会通过Widget的 createRenderObject 方法创建出对应的RenderObject 并与Element一一对应</strong></li></ul><h3 id="RenderObject"><a href="#RenderObject" class="headerlink" title="RenderObject"></a>RenderObject</h3><ul><li>如果想知道一个Widget的实现逻辑, 只需要找到Widget的RenderObject实现即可, 同时Flutter中自定义控件的实现都绕不开RenderObect</li><li>RenderObject属于真正的绘制实例, 它涉及到了布局layout 和绘制paint等真实的界面操作, 可以认为是真正的View(比如iOS和Android中的View)<br>而它的配置信息如: 颜色, 大小, 位置等, 是通过Widget传递过来的, 所以才会有Widget转化为RenderObject实现绘制的说法</li><li>所有的RenderObject的子类都必须实现paint方法才会实现界面显示, 并且该方法并不是给开发者直接调用的, 需要更新绘制时,必须通过markNeedsPaint方法触发界面进行paint绘制</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>Widget、Element、RenderObject 之间的关系如下:<br>Widget与Element之间是多对一关系; 在存在RenderObject的情况下; Element与RenderObject是一一对应的关系.</li></ul><blockquote><p>如图所示</p></blockquote><p><img src="https://wx1.sbimg.cn/2020/06/20/widget.jpg" alt="widget.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Widget&quot;&gt;&lt;a href=&quot;#Widget&quot; class=&quot;headerlink&quot; title=&quot;Widget&quot;&gt;&lt;/a&gt;Widget&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在Flutter中, 一切皆Widget, Widget是不可变的, 每个Widget状态都代表
      
    
    </summary>
    
    
      <category term="Flutter" scheme="https://codeman.netlify.app/categories/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 性能优化</title>
    <link href="https://codeman.netlify.app/2018/08/20/ios/ios-opitimize/"/>
    <id>https://codeman.netlify.app/2018/08/20/ios/ios-opitimize/</id>
    <published>2018-08-20T15:00:40.000Z</published>
    <updated>2020-07-11T08:14:14.929Z</updated>
    
    <content type="html"><![CDATA[<p>在屏幕成像的过程中，CPU和GPU起着至关重要的作用</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul><li>对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制（Core Graphics）</li></ul><h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><ul><li>纹理的渲染, 图像相关的处理</li></ul><p>从CPU到成像的运行流程:</p><p><img src="https://s1.ax1x.com/2020/06/30/N5PdDP.png" alt="N5PdDP.png"></p><blockquote><p>可以说一帧画面的显示离不开CPU和GPU的共同协作</p></blockquote><h3 id="卡顿产生的原因"><a href="#卡顿产生的原因" class="headerlink" title="卡顿产生的原因"></a>卡顿产生的原因</h3><ul><li>在 <code>VSync</code> 信号到来后，系统图形服务会通过 <code>CADisplayLink</code>等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</li></ul><p><img src="https://s1.ax1x.com/2020/06/30/N5MgFs.png" alt="N5MgFs.png"></p><h2 id="性能优化之卡顿优化"><a href="#性能优化之卡顿优化" class="headerlink" title="性能优化之卡顿优化"></a>性能优化之卡顿优化</h2><h3 id="CPU-资源消耗原因和解决方案"><a href="#CPU-资源消耗原因和解决方案" class="headerlink" title="CPU 资源消耗原因和解决方案"></a>CPU 资源消耗原因和解决方案</h3><ul><li><p>对象创建</p><ul><li>对象的创建会分配内存, 尽量用轻量级的对象, 比如<code>CALayer</code>来替代不需要事件响应的<code>UIView</code></li></ul></li><li><p>对象调整</p><ul><li>不要频繁地调用UIView的相关属性，比如frame、bounds、transform等属性，尽量减少不必要的修改</li></ul></li><li><p>对象销毁</p></li><li><p>布局计算</p><ul><li>尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性</li></ul></li><li><p>Autolayout</p><ul><li>在iOS12之前, Autolayout会比直接设置frame消耗更多的CPU资源</li></ul></li><li><p>文本计算</p><ul><li>用 <code>[NSAttributedString boundingRectWithSize:options:context:]</code> 来计算文本宽高，用 <code>-[NSAttributedString drawWithRect:options:context:]</code> 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。</li></ul></li><li><p>文本渲染</p><ul><li>CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</li></ul></li><li><p>图片的解码</p><ul><li>常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</li></ul></li><li><p>图像的绘制</p><ul><li>尽量异步绘制<figure class="highlight objc"><figcaption><span>&#123; .line-numbers &#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)display &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(...);</span><br><span class="line">        <span class="comment">// draw in context...</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> img = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">        <span class="built_in">CFRelease</span>(ctx);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">            layer.contents = img;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="GPU-资源消耗原因和解决方案"><a href="#GPU-资源消耗原因和解决方案" class="headerlink" title="GPU 资源消耗原因和解决方案"></a>GPU 资源消耗原因和解决方案</h3><ul><li>纹理的渲染<ul><li>目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096×4096 所以，尽量不要让图片和视图的大小超过这个值。<br>尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示</li><li>尽量减少视图数量和层次</li></ul></li><li>视图的混合<ul><li>尽量不使用透明度</li></ul></li><li>离屏渲染<ul><li>尽量避免出现离屏渲染<br>如光栅化、遮罩、圆角和裁剪同时设置、阴影</li></ul></li></ul><h3 id="卡顿检测"><a href="#卡顿检测" class="headerlink" title="卡顿检测"></a>卡顿检测</h3><ul><li>可以添加Observer到主线程RunLoop中，通过监听RunLoop状态切换的耗时，以达到监控卡顿的目的</li><li>可以使用优秀的第三方检测库 可以参考<a href="https://github.com/skyming/iOS-Performance-Optimization" target="_blank" rel="noopener">这里</a></li></ul><h3 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h3><ul><li>少用定时器</li><li>优化I/O操作<ul><li>尽量不要频繁写入小数据，最好批量一次性写入<br>读写大量重要数据时，考虑用dispatch_io，其提供了基于GCD的异步操作文件I/O的API。用dispatch_io系统会优化磁盘访问</li></ul></li><li>网络优化: <ul><li>减少、压缩网络数据<br>如果多次请求的结果是相同的,尽量使用缓存,使用断点续传,网络不可用时，不要尝试执行网络请求,设置合适的超时时间. 批量传输减少网络次数, DNS解析, IP直连等</li></ul></li><li>定位优化<ul><li>如果只是需要快速确定用户位置，最好用CLLocationManager的requestLocation方法。定位完成后，会自动让定位硬件断电<br>如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务<br>尽量降低定位精度，比如尽量不要使用精度最高的kCLLocationAccuracyBest<br>需要后台定位时，尽量设置pausesLocationUpdatesAutomatically为YES，如果用户不太可能移动的时候系统会自动暂停位置更新<br>尽量不要使用startMonitoringSignificantLocationChanges，优先考虑startMonitoringForRegion:</li></ul></li><li>硬件检测优化<ul><li>用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件</li></ul></li></ul><h3 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h3><p>启动一个App主要精力如下三个阶段</p><p><img src="https://s1.ax1x.com/2020/06/30/N5YveP.png" alt="N5YveP.png"></p><ul><li><p>dyld</p><ul><li>装载APP的可执行文件，同时会递归加载所有依赖的动态库</li></ul></li><li><p>runtime</p><ul><li>调用所有Class和Category的+load方法</li><li>注册Objc类 、初始化类对象等等</li><li>调用C++静态初始化器和<strong>attribute</strong>((constructor))修饰的函数</li></ul></li><li><p>main</p><ul><li>所有初始化工作结束后，dyld就会调用main函数</li><li>接下来就是UIApplicationMain函数，AppDelegate的application:didFinishLaunchingWithOptions:方法</li></ul></li></ul><p>启动优化要做的🈶️如下几点:</p><h4 id="dyld阶段"><a href="#dyld阶段" class="headerlink" title="dyld阶段"></a>dyld阶段</h4><ol><li>减少动态库、合并一些动态库（定期清理不必要的动态库）</li></ol><h4 id="runtime阶段"><a href="#runtime阶段" class="headerlink" title="runtime阶段"></a>runtime阶段</h4><ol><li>减少Objc类、分类的数量、减少Selector数量（定期清理不必要的类、分类）</li><li>用+initialize方法和dispatch_once取代所有的<strong>attribute</strong>((constructor))、C++静态构造器、ObjC的+load</li><li>减少C++虚函数数量</li><li>Swift尽量使用struct</li></ol><h3 id="main函数之后阶段"><a href="#main函数之后阶段" class="headerlink" title="main函数之后阶段"></a>main函数之后阶段</h3><ol><li>在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在finishLaunching方法中, 按需加载</li></ol><h3 id="安装包大小优化"><a href="#安装包大小优化" class="headerlink" title="安装包大小优化"></a>安装包大小优化</h3><ul><li><p>资源的优化, 去除不需要的无用图片等资源, 对资源进行无损压缩</p></li><li><p>可执行文件的瘦身, 设置一些编译器参数</p><ul><li><code>Strip Linked Product</code>、<code>Make Strings Read-Only</code>、<code>Symbols Hidden by Default</code>设置为<code>YES</code><br>去掉异常支持，<code>Enable C++ Exceptions</code>、<code>Enable Objective-C Exceptions</code>设置为<code>NO</code>， <code>Other C Flags</code>添加<code>-fno-exceptions</code></li></ul></li><li><p>AppCode 开发工具 静态检查未使用的代码</p></li></ul><p>参考链接: </p><ul><li><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#more-41893" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在屏幕成像的过程中，CPU和GPU起着至关重要的作用&lt;/p&gt;
&lt;h3 id=&quot;CPU&quot;&gt;&lt;a href=&quot;#CPU&quot; class=&quot;headerlink&quot; title=&quot;CPU&quot;&gt;&lt;/a&gt;CPU&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;对象的创建和销毁、对象属性的调整、布局计算、文本的计
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://codeman.netlify.app/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 内存布局以及管理</title>
    <link href="https://codeman.netlify.app/2018/07/13/ios/ios-memory/"/>
    <id>https://codeman.netlify.app/2018/07/13/ios/ios-memory/</id>
    <published>2018-07-13T14:00:40.000Z</published>
    <updated>2020-07-11T08:14:56.112Z</updated>
    
    <content type="html"><![CDATA[<h3 id="iOS应用程序的内存布局"><a href="#iOS应用程序的内存布局" class="headerlink" title="iOS应用程序的内存布局"></a>iOS应用程序的内存布局</h3><h4 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h4><ul><li>编译之后的代码存储的区域</li></ul><h4 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h4><ul><li>字符串常量</li><li>已初始化的全局变量, 静态变量</li><li>未初始化的全局变量, 静态变量</li></ul><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ul><li>通过 <code>alloc</code>、<code>malloc</code>、<code>calloc</code> 等动态分配的空间, 内存地址越来越大</li></ul><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul><li>函数调用开销, 比如局部变量, 分配的内存越来越小</li></ul><h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><ul><li>从64位开始, 有了此项技术, 主要是通过指针来直接存储 <code>NSString、NSNumber、NSDate</code> 等小对象.<br>当指针存储不下时,才会动态分配空间来存储到堆中</li><li>在iOS平台指针的最高有效位是1 则证明是Tagged Pointer技术</li></ul><h3 id="Objective-C-对象的内存管理"><a href="#Objective-C-对象的内存管理" class="headerlink" title="Objective-C 对象的内存管理"></a>Objective-C 对象的内存管理</h3><ul><li>OC对象的内存管理是通过引用计数来管理的, 当一个对象创建的时候引用计数为1, 每当对其进行<code>retain</code>操作时, 引用计数(retainCount)会+1, 进行<code>release</code>时引用计数(retainCount)会-1</li><li>当一个对象的引用计数为0时, 则系统会销毁该对象<code>dealloc</code></li></ul><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><ul><li>也就是指针拷贝, 指针存储的地址值相同, 相当于对同一个对象进行<code>retain</code>操作</li></ul><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><ul><li>内容拷贝, 真实的拷贝两份内容, 指针存储的地址值不同.</li></ul><h3 id="copy-和-MutableCopy"><a href="#copy-和-MutableCopy" class="headerlink" title="copy 和 MutableCopy"></a>copy 和 MutableCopy</h3><table><thead><tr><th></th><th>copy操作</th><th>mutableCopy操作</th></tr></thead><tbody><tr><td><code>NSString</code></td><td><code>NSString</code>浅拷贝</td><td><code>NSMutableString</code>深拷贝</td></tr><tr><td><code>NSMutableString</code></td><td><code>NSMutableString</code>深拷贝</td><td><code>NSMutableString</code>深拷贝</td></tr></tbody></table><blockquote><p><code>NSArray</code>、<code>NSMutableArray</code>、<code>NSDictionary</code>、<code>NSMutableDictionary</code> 的拷贝情况跟上面<code>NSString</code>一样</p></blockquote><h3 id="引用计数的存储"><a href="#引用计数的存储" class="headerlink" title="引用计数的存储"></a>引用计数的存储</h3><ul><li><p>在64位架构下, 对象的引用计数可能存储在isa指针中, 当isa指针存储不下的时候会存储在一个全局<code>SideTables</code>(hash表)这种结构里面</p></li><li><p>SideTables里根据对象的地址为key, value为 <code>SideTable</code> 结构</p></li><li><p>SideTable结构如下:</p><ul><li>spinlock_t 一把自旋锁(防止多线程抢占数据错误)</li><li>RefcountMap (hash表) 表里面存着对象的引用计数</li><li>weak_table_t 对象的弱引用计数表里面维护了一个数组存储所有指向当前对象的弱指针</li></ul></li></ul><h3 id="dealloc-做了哪些"><a href="#dealloc-做了哪些" class="headerlink" title="dealloc 做了哪些?"></a>dealloc 做了哪些?</h3><ul><li>_objc_rootDealloc()<ol><li>内部会判断是否有c++析构函数</li><li>是否有关联对象</li><li>是否有弱指针指向<br>如果有的话分别处理上述操作(清除C++变量, 清除关联对象, 清理弱指针为nil)</li></ol></li></ul><h3 id="自动释放池-autoReleasePool"><a href="#自动释放池-autoReleasePool" class="headerlink" title="自动释放池 autoReleasePool"></a>自动释放池 autoReleasePool</h3><ul><li>自动释放池的底层结构主要是 <code>AutoreleasePoolPage</code></li><li>每个<code>AutoreleasePoolPage</code>占用4096字节内存, 前面56个字节用来存储它的内部成员变量, 后面的则会存储着调用<code>autorelease</code>对象地址</li><li>当一个<code>AutoreleasePoolPage</code>不够存储时则会创建一个新的<code>AutoreleasePoolPage</code>, 每个<code>AutoreleasePoolPage</code>之间通过指针连接形成‘双向链表’结构</li></ul><ol><li>调用push方法会将一个POOL_BOUNDARY入栈，并且返回其存放的内存地址</li><li>调用pop方法时传入一个POOL_BOUNDARY的内存地址，会从最后一个入栈的对象开始发送<code>release</code>消息，直到遇到这个POOL_BOUNDARY</li><li><code>id *next</code>指向了下一个能存放<code>autorelease</code>对象地址的区域  </li></ol><p>如图所示</p><p><img src="https://s1.ax1x.com/2020/06/30/N4a02Q.png" alt="N4a02Q.png"></p><h3 id="Runloop和Autorelease"><a href="#Runloop和Autorelease" class="headerlink" title="Runloop和Autorelease"></a>Runloop和Autorelease</h3><ul><li>iOS在主线程的Runloop中注册了2个Observer<br>第1个Observer监听了<code>kCFRunLoopEntry</code>事件，会调用<code>objc_autoreleasePoolPush()</code><br>第2个Observer<br>监听了<code>kCFRunLoopBeforeWaiting</code>事件，会调用<code>objc_autoreleasePoolPop()、objc_autoreleasePoolPush()</code><br>监听了<code>kCFRunLoopBeforeExit</code>事件，会调用<code>objc_autoreleasePoolPop()</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;iOS应用程序的内存布局&quot;&gt;&lt;a href=&quot;#iOS应用程序的内存布局&quot; class=&quot;headerlink&quot; title=&quot;iOS应用程序的内存布局&quot;&gt;&lt;/a&gt;iOS应用程序的内存布局&lt;/h3&gt;&lt;h4 id=&quot;代码段&quot;&gt;&lt;a href=&quot;#代码段&quot; class
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://codeman.netlify.app/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 线程以及线程同步方案</title>
    <link href="https://codeman.netlify.app/2018/06/15/ios/ios-thread/"/>
    <id>https://codeman.netlify.app/2018/06/15/ios/ios-thread/</id>
    <published>2018-06-15T14:00:40.000Z</published>
    <updated>2020-07-11T08:15:17.563Z</updated>
    
    <content type="html"><![CDATA[<h3 id="iOS-中常见的多线程方案"><a href="#iOS-中常见的多线程方案" class="headerlink" title="iOS 中常见的多线程方案"></a>iOS 中常见的多线程方案</h3><p><img src="https://s1.ax1x.com/2020/06/28/N2Xe58.png" alt="N2Xe58.png"></p><h3 id="同步、异步、串行、并发"><a href="#同步、异步、串行、并发" class="headerlink" title="同步、异步、串行、并发"></a>同步、异步、串行、并发</h3><ul><li><em>同步</em> 和 <em>异步</em> 主要是能否开启新的线程<ol><li>同步: 在当前线程中执行任务, 不具备开启新线程的能力</li><li>异步: 在新的线程中执行任务, 具备开启新线程的能力</li></ol></li><li><em>串行</em> 和 <em>并发</em> 主要决定任务的执行方式<ol><li>串行: 一个任务执行完毕再执行下一个任务</li><li>并发: 多个任务同时执行</li></ol></li></ul><h3 id="各种情况的执行效果"><a href="#各种情况的执行效果" class="headerlink" title="各种情况的执行效果"></a>各种情况的执行效果</h3><p><img src="https://s1.ax1x.com/2020/06/28/N2v1A0.png" alt="N2v1A0.png"></p><h3 id="队列组的应用"><a href="#队列组的应用" class="headerlink" title="队列组的应用"></a>队列组的应用</h3><blockquote><p>通过dispatch_group_t 队列组可以实现 所有异步任务共同并发, 任务都处理完毕, 统一触发 通过dispatch_group_notify来进行接下来的任务</p></blockquote><h3 id="多线程同步方案"><a href="#多线程同步方案" class="headerlink" title="多线程同步方案"></a>多线程同步方案</h3><ul><li><p><font color=grey>OSSpinLock</font> </p><ul><li><code>#import &lt;libkern/OSAtomic.h&gt;</code></li><li>自旋, 不推荐使用, 会有优先级反转的问题, 如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁</li></ul></li><li><p><font color=blue>os_unfair_lock</font> </p><ul><li>互斥, 推荐效率较高</li><li><code>os_unfair_lock</code>用于取代不安全的<code>OSSpinLock</code> ，从iOS10开始才支持</li></ul></li><li><p><font color=blue>pthread_mutex</font>  </p><ul><li><code>#import &lt;pthread.h&gt;</code></li><li>互斥, 推荐跨平台</li></ul></li><li><p><font color=blue>dispatch_semaphore</font></p><ul><li>互斥, 推荐, 兼容性好</li></ul></li><li><p>dispatch_queue(DISPATCH_QUEUE_SERIAL)</p><ul><li>串行队列同样可以线程同步</li></ul></li><li><p>NSLock</p><ul><li>对pthread_mutex的OC包装</li></ul></li><li><p>NSRecursiveLock</p><ul><li>对pthread_mutex递归锁的OC包装</li></ul></li><li><p>NSCondition</p><ul><li>对pthread_mutex条件锁的OC包装</li></ul></li><li><p>NSConditionLock</p></li><li><p>@synchronized </p><ul><li>对pthread_mutex递归锁的OC包装</li></ul></li></ul><blockquote><p>死锁<br>当线程加锁之后忘记解锁, 那么这把锁就相当于死锁<br> 如果当前加锁采用的是自旋锁方式, 那么就会一直占用着CPU资源,让其他线程处于忙等状态<br> 如果当前加锁采用的是互斥锁方式, 那么就会让再次获取锁的线程处于休眠状态</p></blockquote><h3 id="iOS中的多读单写方案"><a href="#iOS中的多读单写方案" class="headerlink" title="iOS中的多读单写方案"></a>iOS中的多读单写方案</h3><ul><li><p>场景</p><ul><li>同一时间，只能有1个线程进行写的操作</li><li>同一时间，允许有多个线程进行读的操作</li><li>同一时间，不允许既有写的操作，又有读的操作</li></ul></li><li><p>解决方案:</p><ul><li><code>pthread_rwlock</code> 读写锁</li><li><code>dispatch_barrier_async</code> GCD异步栅栏</li></ul></li></ul><h3 id="NSOperationQueue有哪些优点"><a href="#NSOperationQueue有哪些优点" class="headerlink" title="NSOperationQueue有哪些优点?"></a>NSOperationQueue有哪些优点?</h3><details><summary>参考内容</summary><ol><li>可以添加任务依赖, 方便控制执行顺序</li><li>可以设置任务的优先级</li><li>可以设置最大并发数</li><li>可以控制任务执行状态: isReady,isExecuting,isFinished,isCancelled</details></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;iOS-中常见的多线程方案&quot;&gt;&lt;a href=&quot;#iOS-中常见的多线程方案&quot; class=&quot;headerlink&quot; title=&quot;iOS 中常见的多线程方案&quot;&gt;&lt;/a&gt;iOS 中常见的多线程方案&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://codeman.netlify.app/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS RunLoop</title>
    <link href="https://codeman.netlify.app/2018/05/14/ios/ios-runloop/"/>
    <id>https://codeman.netlify.app/2018/05/14/ios/ios-runloop/</id>
    <published>2018-05-14T12:00:00.000Z</published>
    <updated>2020-07-11T08:15:06.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是RunLoop-都有哪些应用范畴"><a href="#什么是RunLoop-都有哪些应用范畴" class="headerlink" title="什么是RunLoop 都有哪些应用范畴"></a>什么是RunLoop 都有哪些应用范畴</h3><ul><li>运行循环, 用来保证程序的持续运行</li><li>用来处理App的各种事件<ul><li>定时器, performSelector</li><li>GCD Async Main Queue</li><li>事件响应, 手势识别, 界面刷新</li><li>网络请求</li><li>AutoReleasePool</li><li>等等…</li></ul></li></ul><h3 id="RunLoop与线程的关系"><a href="#RunLoop与线程的关系" class="headerlink" title="RunLoop与线程的关系"></a>RunLoop与线程的关系</h3><ul><li>每条线程都有一个与之对应的RunLoop对象</li><li>RunLoop保存在一个全局的字典中, 线程作为Key, RunLoop作为Value, 一一对应</li><li>线程刚刚创建的时候没有RunLoop, 当第一次获取RunLoop时会创建</li><li>RunLoop默认情况下会在线程结束时销毁</li><li>主线程的RunLoop会在程序启动时自动获取</li></ul><h3 id="如何获取当前线程的RunLoop"><a href="#如何获取当前线程的RunLoop" class="headerlink" title="如何获取当前线程的RunLoop"></a>如何获取当前线程的RunLoop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; Foundation </span><br><span class="line">[NSRunLoop currentRunLoop]; &#x2F;&#x2F; 获得当前线程的RunLoop对象</span><br><span class="line">[NSRunLoop mainRunLoop]; &#x2F;&#x2F; 获得主线程的RunLoop对象</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Core Foundation</span><br><span class="line">CFRunLoopGetCurrent(); &#x2F;&#x2F; 获得当前线程的RunLoop对象</span><br><span class="line">CFRunLoopGetMain(); &#x2F;&#x2F; 获得主线程的RunLoop对象</span><br></pre></td></tr></table></figure><h3 id="RunLoop对象结构-以及对外接口"><a href="#RunLoop对象结构-以及对外接口" class="headerlink" title="RunLoop对象结构, 以及对外接口"></a>RunLoop对象结构, 以及对外接口</h3><ul><li>在 CoreFoundation 里面关于 RunLoop 有5个类:<ol><li>CFRunLoopRef</li><li>CFRunLoopModeRef</li><li>CFRunLoopSourceRef</li><li>CFRunLoopTimerRef</li><li>CFRunLoopObserverRef </li></ol></li><li>他们的关系如图所示: </li></ul><p><img src="https://s1.ax1x.com/2020/06/26/NDqPII.jpg" alt="NDqPII.jpg"></p><blockquote><p>一个RunLoop对象包含若干个Mode, 每个Mode包含若干个Source0/Source1/Timers/Observer(统称为 <strong>mode item</strong>)<br>RunLoop启动时只能选择一种mode 作为currentMode<br>如果需要切换Mode, 则需要退出当前Mode, 重新进入新的Mode<br>不同Mode的 Source0/Source1/Timer/Observer 是互相隔离分开的互相不干扰<br>当一个RunLoop中不含任何 Source0/Source1/Timer/Observer 时, RunLoop会立刻退出</p></blockquote><h4 id="RunLoop中常见的Mode"><a href="#RunLoop中常见的Mode" class="headerlink" title="RunLoop中常见的Mode"></a>RunLoop中常见的Mode</h4><ul><li>kCFRunLoopDefaultMode(NSDefaultRunLoopMode):<br>  App的默认mode, 主线程默认情况下在此mode下运行</li><li>UITrackingRunLoopMode: 界面跟踪Mode, 用户ScrollView追踪触摸滑动, 保证界面滑动时不受其他mode影响</li></ul><h3 id="Mode中5个类的解释"><a href="#Mode中5个类的解释" class="headerlink" title="Mode中5个类的解释"></a>Mode中5个类的解释</h3><h4 id="Source0"><a href="#Source0" class="headerlink" title="Source0"></a>Source0</h4><ul><li>触摸事件的处理</li><li>performSelector:onThread:</li></ul><blockquote><p>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</p></blockquote><h4 id="Source1"><a href="#Source1" class="headerlink" title="Source1"></a>Source1</h4><ul><li>基于Port的线程间的通信</li><li>系统事件捕捉<blockquote><p>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程.</p></blockquote></li></ul><h4 id="Timers"><a href="#Timers" class="headerlink" title="Timers"></a>Timers</h4><ul><li>NSTimer定时器</li><li>performSelector:withObject:afterDelay:<blockquote><p>是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p></blockquote></li></ul><h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><ul><li>用于监听RunLoop的各种状态</li><li>UI刷新</li><li>AutoReleasePool 自动释放池</li><li>Observer监听的状态: <ul><li><code>kCFRunLoopEntry</code> // 即将进入Loop</li><li><code>kCFRunLoopBeforeTimers</code> // 即将处理Timers</li><li><code>kCFRunLoopBeforeSources</code> // 即将处理Sources</li><li><code>kCFRunLoopBeforeWaiting</code> // 即将进入休眠</li><li><code>kCFRunLoopAfterWaiting</code> // 刚从睡眠中唤醒</li><li><code>kCFRunLoopExit</code> // 即将退出RunLoop</li></ul></li></ul><h3 id="RunLoop的运行逻辑"><a href="#RunLoop的运行逻辑" class="headerlink" title="RunLoop的运行逻辑"></a>RunLoop的运行逻辑</h3><p><em>文字版</em></p><ol><li>通知Observers：进入Loop</li><li>通知Observers：即将处理Timers</li><li>通知Observers：即将处理Sources</li><li>处理Blocks</li><li>处理Source0（可能会再次处理Blocks）</li><li>如果存在Source1，就跳转到第8步</li><li>通知Observers：开始休眠（等待消息唤醒）</li><li>通知Observers：结束休眠（被某个消息唤醒）<ol><li>处理Timer</li><li>处理GCD Async To Main Queue</li><li>处理Source1</li></ol></li><li>处理Blocks</li><li>根据前面的执行结果，决定如何操作<ol><li>回到第02步</li><li>退出Loop</li></ol></li><li>通知Observers：退出Loop</li></ol><p><em>图片版</em></p><p><img src="https://s1.ax1x.com/2020/06/26/NDOp4I.png" alt="NDOp4I.png"></p><h4 id="RunLoop的休眠原理"><a href="#RunLoop的休眠原理" class="headerlink" title="RunLoop的休眠原理"></a>RunLoop的休眠原理</h4><ul><li>RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。 这个函数属于操作系统内核层面的调度, 可以真正的让CPU处于休息状态, 不处理任何指令.</li><li>如图所示:<br><img src="https://s1.ax1x.com/2020/06/26/NDXCdJ.png" alt="NDXCdJ.png"></li></ul><h3 id="苹果用-RunLoop-实现的功能"><a href="#苹果用-RunLoop-实现的功能" class="headerlink" title="苹果用 RunLoop 实现的功能"></a>苹果用 RunLoop 实现的功能</h3><h4 id="苹果所有mode列举"><a href="#苹果所有mode列举" class="headerlink" title="苹果所有mode列举"></a>苹果所有mode列举</h4><p><img src="https://s1.ax1x.com/2020/06/26/NDvjzt.png" alt="NDvjzt.png"></p><h4 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h4><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p><table><thead><tr><th>Observer监听RunLoop状态</th><th>AutoRelease操作</th></tr></thead><tbody><tr><td><code>kCFRunLoopEntry</code> 进入</td><td><code>_objc_autoreleasePoolPush()</code> 入栈</td></tr><tr><td><code>kCFRunLoopBeforeWaiting</code> 即将休眠</td><td><code>_objc_autoreleasePoolPop()</code> <code>_objc_autoreleasePoolPush()</code> 释放旧的池并创建新池</td></tr><tr><td><code>kCFRunLoopExit</code> 即将退出</td><td><code>_objc_autoreleasePoolPop()</code> 出栈</td></tr></tbody></table><blockquote><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p></blockquote><h4 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h4><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，</p><p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p><p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p><h4 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h4><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p><p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p><p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p><h4 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h4><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被<strong>标记为待处理</strong>，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。</p><blockquote><p>因此 NSTimer CADisplayLink 作为定时器并不是特别的精确<br>如果要求定时任务精确可以使用GCD的定时器,它不依赖于RunLoop</p></blockquote><h4 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h4><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以<strong>如果当前线程没有 RunLoop，则这个方法会失效</strong>。</p><p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，<strong>同样的，如果对应线程没有 RunLoop 该方法也会失效</strong>。</p><h4 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h4><p>实际上 RunLoop 底层也会用到 GCD 的东西, 例如 dispatch_async()。</p><p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p><h4 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h4><p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p><p>另外: AFNetWorking内部单独创建了一个线程，并在这个线程中启动了一个 RunLoop, RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p><hr><p>参考链接:<br><a href="https://blog.ibireme.com/2015/05/18/runloop/#more-41710" target="_blank" rel="noopener">深入理解RunLoop</a><br><a href="https://ke.qq.com/course/314526" target="_blank" rel="noopener">iOS底层原理讲解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是RunLoop-都有哪些应用范畴&quot;&gt;&lt;a href=&quot;#什么是RunLoop-都有哪些应用范畴&quot; class=&quot;headerlink&quot; title=&quot;什么是RunLoop 都有哪些应用范畴&quot;&gt;&lt;/a&gt;什么是RunLoop 都有哪些应用范畴&lt;/h3&gt;&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="iOS" scheme="https://codeman.netlify.app/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS Runtime</title>
    <link href="https://codeman.netlify.app/2018/04/15/ios/ios-runtime/"/>
    <id>https://codeman.netlify.app/2018/04/15/ios/ios-runtime/</id>
    <published>2018-04-15T14:00:40.000Z</published>
    <updated>2020-07-11T08:15:11.562Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Runtime"><a href="#什么是Runtime" class="headerlink" title="什么是Runtime"></a>什么是Runtime</h3><ul><li>Objective-C是一门动态性比较强的编程语言，跟C、C++等语言有着很大的不同, 很多操作会推迟到运行时再进行</li><li>OC的动态性就是有Runtime来支撑和实现的, 它是一套C语言API, 封装了很多动态性相关的函数</li><li>平时编写的OC代码底层都是转换成了Runtime API进行调用</li></ul><h3 id="64位CPU架构下的-isa-指针详解"><a href="#64位CPU架构下的-isa-指针详解" class="headerlink" title="64位CPU架构下的 isa 指针详解"></a>64位CPU架构下的 isa 指针详解</h3><ul><li>64位CPU架构之前,isa指针仅仅是存储者当前类对象的地址值</li><li>64位CPU架构下, 对isa进行了优化, 变成了共用体结构, 使用位域操作来存储更多的内容<blockquote><p>如是否有过关联对象, 是否有C++析构函数, 是否有弱引用指向过, 是否正在析构, 引用计数 等等</p></blockquote></li></ul><h3 id="OC的消息机制"><a href="#OC的消息机制" class="headerlink" title="OC的消息机制"></a>OC的消息机制</h3><ul><li><p>OC中的方法, 其实就是给消息接受者发送一条消息, 底层实现是Runtime 的 objc_msgSend() 传入消息的接受者receiver和方法名selector</p></li><li><p>objc_msgSend 底层有三大阶段<br>   1.消息发送(缓存, 当前方法列表, 父类循环查找)<br>   2.动态方法解析(resoveInstanceMethod, 可以动态的添加方法, 如果实现了动态方法解析, 那么会重新走一次消息发送)<br>   3.消息转发 </p><pre><code>`forwardingTargetForSelector``methodSignatureForSelector:``forwardInvocation`</code></pre></li><li><p>流程如下图所示</p><ul><li><p>消息发送<br><img src="https://wx2.sbimg.cn/2020/06/24/image5b82c619bc9ddefc.png" alt="image5b82c619bc9ddefc.png">  </p><br></li><li><p>动态方法解析<br><img src="https://wx1.sbimg.cn/2020/06/24/image4be831b95b960c31.png" alt="image4be831b95b960c31.png"></p><br></li><li><p>消息转发<br><img src="https://wx2.sbimg.cn/2020/06/24/imagea19574eb69c22e47.png" alt="imagea19574eb69c22e47.png"></p><br></li></ul></li></ul><h3 id="super调用的本质"><a href="#super调用的本质" class="headerlink" title="super调用的本质"></a>super调用的本质</h3><ul><li>super的本质是底层的 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSendSuper2(</span><br><span class="line">    &#123;self, Class&#125;,</span><br><span class="line">    @selector())</span><br></pre></td></tr></table></figure></li><li>相当于还是当前对象为消息接受者, 只不过消息查找从superclass 中开始查找</li></ul><h3 id="Runtime在实际开发中的应用举例"><a href="#Runtime在实际开发中的应用举例" class="headerlink" title="Runtime在实际开发中的应用举例"></a>Runtime在实际开发中的应用举例</h3><ul><li>查找并不公开的成员变量, 来进行想要的操作,比如通过KVC进行修改, 或获取值</li><li>可以遍历成员变量来进行json转数据实体</li><li>可以进行方法交换来拦截系统或者第三方库中的方法,来进行修改达到想要的操作</li></ul><h4 id="RunTime常用API"><a href="#RunTime常用API" class="headerlink" title="RunTime常用API"></a>RunTime常用API</h4><p><em>类</em></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态创建一个类（参数：父类，类名，额外的内存空间）</span></span><br><span class="line">Class objc_allocateClassPair(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t extraBytes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册一个类（要在类注册之前添加成员变量）</span></span><br><span class="line"><span class="keyword">void</span> objc_registerClassPair(Class cls) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁一个类</span></span><br><span class="line"><span class="keyword">void</span> objc_disposeClassPair(Class cls)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取isa指向的Class</span></span><br><span class="line">Class object_getClass(<span class="keyword">id</span> obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置isa指向的Class</span></span><br><span class="line">Class object_setClass(<span class="keyword">id</span> obj, Class cls)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个OC对象是否为Class</span></span><br><span class="line"><span class="built_in">BOOL</span> object_isClass(<span class="keyword">id</span> obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个Class是否为元类</span></span><br><span class="line"><span class="built_in">BOOL</span> class_isMetaClass(Class cls)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父类</span></span><br><span class="line">Class class_getSuperclass(Class cls)</span><br></pre></td></tr></table></figure><p><em>成员变量</em></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个实例变量信息</span></span><br><span class="line">Ivar class_getInstanceVariable(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝实例变量列表（最后需要调用free释放）</span></span><br><span class="line">Ivar *class_copyIvarList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置和获取成员变量的值</span></span><br><span class="line"><span class="keyword">void</span> object_setIvar(<span class="keyword">id</span> obj, Ivar ivar, <span class="keyword">id</span> value)</span><br><span class="line"><span class="keyword">id</span> object_getIvar(<span class="keyword">id</span> obj, Ivar ivar)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态添加成员变量（已经注册的类是不能动态添加成员变量的）</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addIvar(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> * name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> * types)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量的相关信息</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ivar_getName(Ivar v)</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ivar_getTypeEncoding(Ivar v)</span><br></pre></td></tr></table></figure><p><em>属性</em></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个属性</span></span><br><span class="line">objc_property_t class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝属性列表（最后需要调用free释放）</span></span><br><span class="line">objc_property_t *class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态添加属性</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes,</span><br><span class="line">                  <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态替换属性</span></span><br><span class="line"><span class="keyword">void</span> class_replaceProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes,</span><br><span class="line">                      <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性的一些信息</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getName(objc_property_t property)</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getAttributes(objc_property_t property)</span><br></pre></td></tr></table></figure><p><em>方法</em></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得一个实例方法、类方法</span></span><br><span class="line">Method class_getInstanceMethod(Class cls, SEL name)</span><br><span class="line">Method class_getClassMethod(Class cls, SEL name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法实现相关操作</span></span><br><span class="line">IMP class_getMethodImplementation(Class cls, SEL name) </span><br><span class="line">IMP method_setImplementation(Method m, IMP imp)</span><br><span class="line"><span class="keyword">void</span> method_exchangeImplementations(Method m1, Method m2) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝方法列表（最后需要调用free释放）</span></span><br><span class="line">Method *class_copyMethodList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态添加方法</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态替换方法</span></span><br><span class="line">IMP class_replaceMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法的相关信息（带有copy的需要调用free去释放）</span></span><br><span class="line">SEL method_getName(Method m)</span><br><span class="line">IMP method_getImplementation(Method m)</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *method_getTypeEncoding(Method m)</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> method_getNumberOfArguments(Method m)</span><br><span class="line"><span class="keyword">char</span> *method_copyReturnType(Method m)</span><br><span class="line"><span class="keyword">char</span> *method_copyArgumentType(Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择器相关</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *sel_getName(SEL sel)</span><br><span class="line">SEL sel_registerName(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用block作为方法实现</span></span><br><span class="line">IMP imp_implementationWithBlock(<span class="keyword">id</span> block)</span><br><span class="line"><span class="keyword">id</span> imp_getBlock(IMP anImp)</span><br><span class="line"><span class="built_in">BOOL</span> imp_removeBlock(IMP anImp)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是Runtime&quot;&gt;&lt;a href=&quot;#什么是Runtime&quot; class=&quot;headerlink&quot; title=&quot;什么是Runtime&quot;&gt;&lt;/a&gt;什么是Runtime&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Objective-C是一门动态性比较强的编程语言，跟C、C++
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://codeman.netlify.app/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Objective-C 语言底层原理</title>
    <link href="https://codeman.netlify.app/2018/03/15/ios/init_bloc/"/>
    <id>https://codeman.netlify.app/2018/03/15/ios/init_bloc/</id>
    <published>2018-03-15T14:26:40.000Z</published>
    <updated>2020-07-11T08:14:23.608Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我们平时编写的Objective-C代码，底层实现其实都是C-C-代码"><a href="#我们平时编写的Objective-C代码，底层实现其实都是C-C-代码" class="headerlink" title="我们平时编写的Objective-C代码，底层实现其实都是C\C++代码"></a>我们平时编写的Objective-C代码，底层实现其实都是C\C++代码</h3><ul><li>Objective-C -&gt; C/C++ -&gt; 汇编 -&gt; 机器语言</li><li>所以Objective-C的面向对象都是基于C\C++的数据结构实现的(结构体)</li></ul><h3 id="对象的isa指针指向哪里？"><a href="#对象的isa指针指向哪里？" class="headerlink" title="对象的isa指针指向哪里？"></a>对象的isa指针指向哪里？</h3><ul><li>instance对象的isa指向class对象</li><li>class对象的isa指向meta-class对象</li><li>meta-class对象的isa指向基类的meta-class对象</li></ul><h3 id="OC的类信息存放在哪里？"><a href="#OC的类信息存放在哪里？" class="headerlink" title="OC的类信息存放在哪里？"></a>OC的类信息存放在哪里？</h3><ul><li>成员变量的具体值，存放在instance对象</li><li>对象方法、属性、成员变量、协议信息，存放在class对象中</li><li>类方法，存放在meta-class对象中</li></ul><p><strong>如图所示</strong></p><p><img src="https://wx1.sbimg.cn/2020/06/17/WX20200617-2204452x.png" alt="RUNOOB 图标"></p><h3 id="KVO本质是什么"><a href="#KVO本质是什么" class="headerlink" title="KVO本质是什么?"></a>KVO本质是什么?</h3><ul><li><p>利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类</p></li><li><p>当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_NSSetXXXValueAndNotify 函数内部大致如下:</span><br><span class="line">willChangeValueForKey:</span><br><span class="line">父类原来的setter</span><br><span class="line">didChangeValueForKey:</span><br><span class="line">内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）</span><br></pre></td></tr></table></figure></li></ul><h3 id="KVC的赋值和取值过程是怎样的？原理是什么？"><a href="#KVC的赋值和取值过程是怎样的？原理是什么？" class="headerlink" title="KVC的赋值和取值过程是怎样的？原理是什么？"></a>KVC的赋值和取值过程是怎样的？原理是什么？</h3><ul><li><img src="https://wx2.sbimg.cn/2020/06/17/WX20200617-2222362x.png" alt="WX20200617-2222362x.png"></li></ul><h3 id="Category的实现原理"><a href="#Category的实现原理" class="headerlink" title="Category的实现原理"></a>Category的实现原理</h3><ul><li>Category编译之后的底层结构是struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息<br>在程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象、元类对象中）, 分类按编译顺序来合并, 后编译的方法属性等会排在列表的前面</li></ul><h3 id="关联对象的本质"><a href="#关联对象的本质" class="headerlink" title="关联对象的本质"></a>关联对象的本质</h3><ul><li>关联对象并不是存储在被关联对象本身内存中<br>关联对象存储在全局的统一的一个AssociationsManager中(全局的字典)</li></ul><h3 id="Block的本质"><a href="#Block的本质" class="headerlink" title="Block的本质"></a>Block的本质</h3><ul><li>Block是封装了函数以及函数调用的OC对象<br>其内部构造如图所示:<br><img src="https://wx1.sbimg.cn/2020/06/22/image.png" alt="image.png"></li></ul><h5 id="Block的捕获类型"><a href="#Block的捕获类型" class="headerlink" title="Block的捕获类型"></a>Block的捕获类型</h5><ul><li>auto局部变量是值捕获<br>如果是基本数据类型: 值捕获只会将数值拷贝一份到内部存储<br>如果是对象数据类型: 根据外面对象是否为retain来进行是否retain操作</li><li>static局部静态是引用捕获</li><li>全局变量 不进行捕获</li></ul><h5 id="Block的类型"><a href="#Block的类型" class="headerlink" title="Block的类型"></a>Block的类型</h5><ul><li>默认情况下是NSGlobalBlock</li><li>访问了auto变量为NSStackBlock</li><li>NSStackBlock进行了Copy操作则变成NSMallocBlock</li></ul><h5 id="block-修饰符"><a href="#block-修饰符" class="headerlink" title="__block 修饰符"></a>__block 修饰符</h5><ul><li>会将auto变量进行包装成block内部的 OC对象<br>如果是基本数据类型:Block内部的OC对象内部会拷贝一份外面的数值<br>如果是对象数据类型:Block内部的OC对象内部会对外面的对象根据外面对象是否为retain来进行是否retain操作</li><li>被<strong>block修饰的外部变量 在block内部访问时 本质是通过 Block内部生成的</strong>Block对象内部的forwarding指针指向的自己来进行访问, 主要是解决当Block在栈存储区时,确保访问的外部变量是在堆上</li></ul><h5 id="Block本身的拷贝操作对外面引用变量的影响"><a href="#Block本身的拷贝操作对外面引用变量的影响" class="headerlink" title="Block本身的拷贝操作对外面引用变量的影响"></a>Block本身的拷贝操作对外面引用变量的影响</h5><ul><li>如果Block从栈存储区拷贝的堆存储区则会调用desc结构体内部的copy操作(被__block修饰的同样, 只是多了一层对象包装)</li></ul><h5 id="Block引起的循环引用"><a href="#Block引起的循环引用" class="headerlink" title="Block引起的循环引用"></a>Block引起的循环引用</h5><ul><li>循环引用主要是指外部变量对Block进行多了retain操作, Block内部又对外部变量进行了retain操作, 导致双方的引用计数无法release到0释放, 所以常驻内存导致内存泄漏, 常用的解决方法是将Block内部引用的外部变量进行__weak弱引用, 这样便不会retain操作,可以销毁.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;我们平时编写的Objective-C代码，底层实现其实都是C-C-代码&quot;&gt;&lt;a href=&quot;#我们平时编写的Objective-C代码，底层实现其实都是C-C-代码&quot; class=&quot;headerlink&quot; title=&quot;我们平时编写的Objective-C代码，底
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://codeman.netlify.app/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS Mach-O 格式文件</title>
    <link href="https://codeman.netlify.app/2017/05/20/ios/ios-reverse-3/"/>
    <id>https://codeman.netlify.app/2017/05/20/ios/ios-reverse-3/</id>
    <published>2017-05-20T15:00:40.000Z</published>
    <updated>2020-07-11T09:19:42.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mach-O-介绍"><a href="#Mach-O-介绍" class="headerlink" title="Mach-O 介绍"></a>Mach-O 介绍</h2><p><code>Mach-O</code> 其实是 <code>Mach Object</code> 文件格式的缩写, 属于<code>Mach-O</code>格式的常见文件有</p><ul><li>目标文件.o</li><li>库文件<ul><li>.a 静态库其实就是多个.o链接到一起</li><li>.dylib </li><li>framework</li></ul></li><li>可执行文件</li><li>dyld (动态链接器)</li><li>.dsym( 符号表)</li></ul><p>如图所示:<br><img src="https://s1.ax1x.com/2020/07/11/Ul8OaR.png" alt="Ul8OaR.png"></p><h3 id="在Xcode中可查看-Mach-O-文件类型"><a href="#在Xcode中可查看-Mach-O-文件类型" class="headerlink" title="在Xcode中可查看 Mach-O 文件类型"></a>在Xcode中可查看 Mach-O 文件类型</h3><ul><li>如图<br>  <img src="https://s1.ax1x.com/2020/07/11/UlGdL4.png" alt="UlGdL4.png"></li></ul><h2 id="Mach-O-的基本结构"><a href="#Mach-O-的基本结构" class="headerlink" title="Mach-O 的基本结构"></a>Mach-O 的基本结构</h2><ul><li>Header<ul><li>文件类型、目标架构类型等</li></ul></li><li>Load commands<ul><li>描述文件在虚拟内存中的逻辑结构、布局</li></ul></li><li>Raw segment data<ul><li>在Load commands 中定义的 Segment 原始数据</li></ul></li></ul><p>如图所示:<br>    <img src="https://s1.ax1x.com/2020/07/11/UlGvwj.png" alt="UlGvwj.png"></p><h2 id="查看-Mach-O-文件结构"><a href="#查看-Mach-O-文件结构" class="headerlink" title="查看 Mach-O 文件结构"></a>查看 Mach-O 文件结构</h2><ul><li><p>命令行工具</p><ul><li>file  查看文件类型</li><li>otool  用来查看特定部分和段的内容</li><li>lipo  用于多架构文件的处理<ul><li>lipo -info &lt;文件路径&gt;</li><li>lipo &lt;文件路径&gt; -thin &lt;架构类型&gt; -output &lt;导出的文件目录&gt;</li><li>lipo &lt;文件路径1&gt; &lt;文件路径2&gt; -output &lt;输出的文件路径&gt; </li></ul></li></ul></li><li><p>GUI 工具</p><ul><li><a href="https://github.com/gdbinit/MachOView" target="_blank" rel="noopener">MachOView</a></li></ul></li></ul><blockquote><p>dyld 用于加载以下几种<code>Mach-O</code>格式文件:</p><ol><li>可执行文件</li><li>dylib 动态库</li><li>bundle </li></ol></blockquote><h2 id="App从开发到安装到手机上的过程"><a href="#App从开发到安装到手机上的过程" class="headerlink" title="App从开发到安装到手机上的过程"></a>App从开发到安装到手机上的过程</h2><ol><li>编写代码</li><li>编译、链接、签名 生成 .app 包</li><li>.app包内包含<strong>可执行文件</strong>和一些资源</li><li>压缩.app包为ipa文件</li><li>ipa文件可以上传到 AppStore 或者 其他商店</li><li>用户从AppStore 或其他商店 安装ipa</li></ol><h2 id="逆向App思路"><a href="#逆向App思路" class="headerlink" title="逆向App思路"></a>逆向App思路</h2><ol><li>界面分析<ul><li><code>Cycript</code>、<code>Reveal</code></li></ul></li><li>代码分析<ul><li>对<code>Mach-O</code>文件静态分析</li><li>主要工具有: <code>MachOView</code>、<a href="http://stevenygard.com/projects/class-dump/" target="_blank" rel="noopener">class-dump</a>、<code>Hopper Disassembler</code>、<code>ida</code></li></ul></li><li>动态调试<ul><li><code>debugserver</code>、<code>LLDB</code></li></ul></li><li>编写代码注入到App中<ul><li><code>theos</code> hook方式编写deb安装包 Cydia安装deb插件(已越狱)</li><li>重签名、打包ipa(未越狱)</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Mach-O-介绍&quot;&gt;&lt;a href=&quot;#Mach-O-介绍&quot; class=&quot;headerlink&quot; title=&quot;Mach-O 介绍&quot;&gt;&lt;/a&gt;Mach-O 介绍&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Mach-O&lt;/code&gt; 其实是 &lt;code&gt;Mach Object&lt;
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://codeman.netlify.app/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 逆向-分析工具 Cycript、Reaveal</title>
    <link href="https://codeman.netlify.app/2017/04/20/ios/ios-reverse-2/"/>
    <id>https://codeman.netlify.app/2017/04/20/ios/ios-reverse-2/</id>
    <published>2017-04-20T15:00:40.000Z</published>
    <updated>2020-07-11T08:14:15.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cycript"><a href="#Cycript" class="headerlink" title="Cycript"></a>Cycript</h2><ul><li>Cycript是Objective-C++、ES6（JavaScript）、Java等语法的混合物<br>可以用来探索、修改、调试正在运行的Mac\iOS APP<br>可以在<a href="http://www.cycript.org/" target="_blank" rel="noopener">官网</a>或者<a href="http://www.cycript.org/manual/" target="_blank" rel="noopener">文档</a>来查看相应说明</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>在越狱的手机上 通过Cydia安装Cycript，即可在iPhone上调试运行中的APP</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h3><ul><li>cycript -p 进程名称/进程ID<blockquote><p>通过输入-p参数 后面跟上进程名称或进程ID即可进入cycript运行环境进行调试<br>取消输入: <code>Ctrl + C</code> 退出: <code>Ctrl + D</code>  清屏: <code>Command + R</code><br>命令行列出所有进程: <code>ps -A</code>  也可以搜索关键词 <code>ps -A | grep 关键词</code></p></blockquote></li></ul><h3 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h3><ul><li>UIApp<ul><li>代表 [UIApplication sharedApplication]</li></ul></li><li>var app = [UIApplication sharedApplication]<ul><li>定义变量</li></ul></li><li>#0x13ba34500<ul><li>用内存地址获取对象</li></ul></li><li>ObjectiveC.classes<ul><li>已加载的所有OC类</li></ul></li><li>*对象<ul><li>查看对象的所有成员变量</li></ul></li><li>view.recursiveDescription().toString()<ul><li>递归打印view的所有子控件（跟LLDB一样的函数）</li></ul></li><li>choose(UIViewController)<ul><li>筛选出某种类型的对象<blockquote><p>可以使用MJ封装的<a href="https://github.com/CoderMJLee/mjcript" target="_blank" rel="noopener">mjcript</a>来使用, 封装了更多好用的函数</p></blockquote></li></ul></li></ul><h2 id="Reveal"><a href="#Reveal" class="headerlink" title="Reveal"></a>Reveal</h2><ul><li><a href="https://revealapp.com" target="_blank" rel="noopener">Reveal</a>是一款调试iOS程序UI界面的神器</li></ul><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><ul><li>想要调试任何app, 需要做以下三件事<ul><li><ol><li>在越狱的手机上通过<code>Cydia</code>安装<code>Reveal Loader</code></li></ol></li><li><ol start="2"><li>手机上点击<code>设置</code>-&gt;<code>Reveal</code>-&gt;<code>Enabled Applications</code> 打开需要调试的App的开关</li></ol></li><li><ol start="3"><li>打开Mac电脑上的Reveal, 点击顶部菜单的 <code>Help</code>-&gt;<code>Show Reveal Library in Finder</code>, 然后将看到的 <code>RevealSever.framwork</code> 拷贝到手机上的目录: <code>Library</code>-&gt;<code>Frameworks</code> 中</li></ol></li></ul></li></ul><p>重启iOS设备的 SpringBoard: <code>killall SpringBoard</code> (通过mac命令汗运行)<br>至此可以通过Reveal查看任何运行中的App了, 可以通过 <code>Cycript + Reveal</code> 两个工具进行详细的分析</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Cycript&quot;&gt;&lt;a href=&quot;#Cycript&quot; class=&quot;headerlink&quot; title=&quot;Cycript&quot;&gt;&lt;/a&gt;Cycript&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Cycript是Objective-C++、ES6（JavaScript）、Java等语
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://codeman.netlify.app/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 逆向-越狱环境搭建</title>
    <link href="https://codeman.netlify.app/2017/03/20/ios/ios-reverse-1/"/>
    <id>https://codeman.netlify.app/2017/03/20/ios/ios-reverse-1/</id>
    <published>2017-03-20T15:00:40.000Z</published>
    <updated>2020-07-11T08:14:14.998Z</updated>
    
    <content type="html"><![CDATA[<p>首先逆向需要一台 <strong>Mac电脑</strong>, 还有一台<strong>已经越狱的 iOS 设备</strong></p><h2 id="越狱工具"><a href="#越狱工具" class="headerlink" title="越狱工具"></a>越狱工具</h2><p>市面上的越狱工具有很多, 例如:</p><ul><li><a href="https://unc0ver.dev/" target="_blank" rel="noopener">uncOver</a></li><li><a href="https://checkra.in/" target="_blank" rel="noopener">checkra1n</a><blockquote><p>可以自行选择越狱工具, 通过越狱工具官网查看支持的设备以及系统版本号来进行选择, 然后通过官网步骤即可完成越狱</p></blockquote></li></ul><h2 id="通过-Cydia-安装逆向所需插件"><a href="#通过-Cydia-安装逆向所需插件" class="headerlink" title="通过 Cydia 安装逆向所需插件"></a>通过 <code>Cydia</code> 安装逆向所需插件</h2><p>越狱成功的手机, 会自动安装一个叫 <code>Cydia</code> 的软件, 它相当于一个软件商店, 可以下载一些好用的插件或软件来让越狱的手机更方便, 前提需要添加一些好用的“源”(可以自行搜索).<br>越狱之后逆向所需插件如下:</p><ul><li><code>Apple File Conduit &quot;2&quot;</code>    可以访问整个iOS设备的文系统, 类似的补丁还有：<code>afc2</code>、<code>afc2add</code></li><li><code>AppSync Unified</code>  可以绕过系统验证，随意安装、运行破解的ipa安装包</li></ul><h2 id="通过-SSH-登录iOS设备"><a href="#通过-SSH-登录iOS设备" class="headerlink" title="通过 SSH 登录iOS设备"></a>通过 SSH 登录iOS设备</h2><ul><li>在iOS设备上上通过<code>Cydia</code>安装<code>OpenSSH</code>工具</li><li>在Mac的终端输入 <code>ssh 账户名@服务器主机地址</code><br>比如 <code>ssh root@10.1.1.168</code>（这里的服务器是手机）<br>初始密码 <code>alpine</code></li><li>退出登录命令是 <code>exit</code><blockquote><p>root：最高权限账户，$HOME 是 /var/root</p></blockquote></li></ul><h3 id="ssh-一些其他操作"><a href="#ssh-一些其他操作" class="headerlink" title="ssh 一些其他操作"></a>ssh 一些其他操作</h3><ul><li>删掉之前的服务器公钥信息<ul><li><code>ssh-keygen -R 服务器IP地址</code></li></ul></li><li>或者直接打开known_hosts文件删除服务器的公钥信息就行<ul><li><code>vim ~/.ssh/known_hosts</code></li></ul></li></ul><h3 id="ssh-基于密钥方式的客户端认证"><a href="#ssh-基于密钥方式的客户端认证" class="headerlink" title="ssh 基于密钥方式的客户端认证"></a>ssh 基于密钥方式的客户端认证</h3><ul><li>在客户端生成一对相关联的密钥（Key Pair）：一个公钥（Public Key），一个私钥（Private Key）<ul><li><code>ssh-keygen</code>  一路敲回车键（Enter）即可</li></ul></li><li>把客户端的公钥内容追加到服务器的授权文件（~/.ssh/authorized_keys）尾部<ul><li><code>ssh-copy-id root@服务器主机地址</code><blockquote><p>ssh-copy-id会将客户端<del>/.ssh/id_rsa.pub的内容自动追加到服务器的</del>/.ssh/authorized_keys尾部<br>如果配置了免密码登录后，还是需要输入密码，需要在服务器端设置文件权限 <code>chmod 644 ~/.ssh/authorized_keys</code></p></blockquote></li></ul></li></ul><h2 id="通过-USB-连接线连接-iOS-设备"><a href="#通过-USB-连接线连接-iOS-设备" class="headerlink" title="通过 USB 连接线连接 iOS 设备"></a>通过 USB 连接线连接 iOS 设备</h2><ul><li>需要用到<a href="https://cgit.sukimashita.com/usbmuxd.git/snapshot/usbmuxd-1.0.8.tar.gz" target="_blank" rel="noopener">usbmuxd</a>工具包里面的一个python脚本：<code>tcprelay.py</code> 来进行端口映射</li><li>将iPhone的22端口（SSH端口）映射到Mac本地的10010端口(10010也可以换成其他系统未占用的端口)<ul><li><code>python tcprelay.py -t 22:10010</code></li></ul></li><li>端口映射完毕后，以后如果想跟iPhone的22端口通信，直接跟Mac本地的10010端口通信就可以了<ul><li><code>ssh root@localhost -p 10010</code><blockquote><p>远程拷贝文件也可以直接跟Mac本地的10010端口通信<br>scp -P 10010 <del>/Desktop/1.txt root@localhost:</del>/test<br>我们可以将经常执行的一系列终端命令行放到sh脚本文件中（shell），然后执行脚本文件</p></blockquote></li></ul></li></ul><p>至此, 逆向所需要的环境基本搭建完成</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先逆向需要一台 &lt;strong&gt;Mac电脑&lt;/strong&gt;, 还有一台&lt;strong&gt;已经越狱的 iOS 设备&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;越狱工具&quot;&gt;&lt;a href=&quot;#越狱工具&quot; class=&quot;headerlink&quot; title=&quot;越狱工具&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://codeman.netlify.app/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>博客搬家了</title>
    <link href="https://codeman.netlify.app/2016/05/13/new-bloc/"/>
    <id>https://codeman.netlify.app/2016/05/13/new-bloc/</id>
    <published>2016-05-13T02:26:44.000Z</published>
    <updated>2020-06-28T06:10:49.471Z</updated>
    
    <content type="html"><![CDATA[<p>之前的博客地址<a href="https://home.cnblogs.com/u/zhangguoliang1992" target="_blank" rel="noopener">博客园</a>已不在更新,<br>本博客采用 <code>Hexo</code> + <code>Github Pages</code> + <code>Netlify</code> 搭建</p><h4 id="新博客的目标"><a href="#新博客的目标" class="headerlink" title="新博客的目标"></a>新博客的目标</h4><ul><li>多记录整块的知识体系,而不是分散的知识点</li><li>每个分类或标签下的知识体系可以串联</li></ul><h4 id="博客主攻技术方向"><a href="#博客主攻技术方向" class="headerlink" title="博客主攻技术方向"></a>博客主攻技术方向</h4><ul><li>iOS应用开发, Objective-C、Swift</li><li>跨平台方向</li><li>Android相关(了解), Java</li><li>脚本语言 Shell、Ruby、Python</li><li>Linux 常用命令</li><li>网络</li><li>算法</li><li>数据结构基础、编译原理</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>设计 <code>Pixelmator pro</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前的博客地址&lt;a href=&quot;https://home.cnblogs.com/u/zhangguoliang1992&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;博客园&lt;/a&gt;已不在更新,&lt;br&gt;本博客采用 &lt;code&gt;Hexo&lt;/code&gt; + &lt;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
